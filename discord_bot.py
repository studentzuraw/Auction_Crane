"""
Auctionator discord bot
"""
import discord
from discord.ext import commands
import simple_search_engine
import auctionator_graph_generator

intents = discord.Intents.default()
intents.message_content = True
intents.messages = True


def read_token():
    """
    Read token file and return token string
    """
    with open("token.txt", "r", encoding="utf-8") as token_file:
        lines = token_file.readlines()
        return lines[0].strip()


token = read_token()

bot = commands.Bot(intents=intents, command_prefix=commands.when_mentioned_or("$ac "))


@bot.event
async def on_ready():
    """
    Sending message in console when bot is ready to use
    """
    print(f"Logged in as {bot.user} (ID: {bot.user.id})")


@bot.command(name="price")
async def price(ctx, *, msg_1):
    """
    Reacting to $ac choose <number> command and returning response message
    """
    global FOUND_ITEMSS
    FOUND_ITEMSS = simple_search_engine.sse_search_start(msg_1)
    response_msg = ""
    if len(FOUND_ITEMSS) <= 0:
        response_msg += " No matches found for " + msg_1 + "!"
    elif len(FOUND_ITEMSS) == 1:
        response_msg += "1." + FOUND_ITEMSS[0]
    else:
        for i, line in enumerate(FOUND_ITEMSS, 1):
            response_msg += str(i) + ". " + line + "\n"
    embed_var = discord.Embed(
        title="Please type in: $ac choose <number> ", color=0x00FF00
    )
    embed_var.add_field(name="Choose from list:", value=response_msg)
    choose.reset_cooldown(ctx)
    await ctx.send(embed=embed_var)


@bot.command(name="choose")
@commands.cooldown(1, 99999999999999999999, commands.BucketType.user)
async def choose(ctx, msg):
    """
    Reacting to $ac choose <number> works after price command
    """
    try:
        output_item_name = simple_search_engine.sse_pick_item(msg, FOUND_ITEMSS)
        print(output_item_name)
        (
            _,
            _,
            latest_price,
            latest_price_date,
            _,
            trend_coef,
        ) = auctionator_graph_generator.calculation_before_plotting(output_item_name)

        latest_price = latest_price * 10000
        gold = int(latest_price / 10000)
        silver = int((latest_price - (gold * 10000)) / 100)
        bronze = int(latest_price - (gold * 10000) - (silver * 100))
        latest_price_prettyfied = (
            str(gold)
            + " :yellow_circle: "
            + str(silver)
            + " :white_circle: "
            + str(bronze)
            + " :brown_circle: "
        )
        if trend_coef > 0:
            trend_string = "Rising"
        elif trend_coef == 0:
            trend_string = "Stable"
        elif trend_coef < 0:
            trend_string = "Decreasing"

        if output_item_name.find("ERR") != -1:
            await ctx.send(output_item_name)
        else:
            graph_image = discord.File("graph.png")
            embed_var2 = discord.Embed(
                title="Current pricing information", color=0x00FF00
            )
            embed_var2.set_image(url="attachment://graph.png")
            embed_var2.set_footer(text="Info generated by Auction Crane")
            embed_var2.add_field(name="Item name", value=output_item_name, inline=False)
            embed_var2.add_field(
                name="Latest Price", value=latest_price_prettyfied, inline=True
            )
            embed_var2.add_field(
                name="Latest Price date", value=latest_price_date, inline=True
            )
            embed_var2.add_field(name="Price trend", value=trend_string, inline=True)
            choose.update(enable=False)
            await ctx.send(embed=embed_var2, file=graph_image)
    except NameError:
        await ctx.send("Please use $ac price <item name> first!")


@bot.event
async def on_command_error(ctx, error):
    """
    Checking if the choose command was used twice, blocking choose after one use
    """
    if isinstance(error, commands.CommandOnCooldown):
        await ctx.send("You can't choose twice!\nUse $ac price <item name> first!")


bot.run(token)
